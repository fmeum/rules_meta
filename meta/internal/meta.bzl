load(":forwarding.bzl", "transition_and_forward_providers_factory")
load(":utils.bzl", "attr_from_value", "is_dict", "is_list", "is_select")

def wrap_with_transition(
        original_rule,
        settings,
        executable = False,
        test = False,
        extra_providers = []):
    """Creates a new rule that behaves like an existing rule but also modifies build settings.

    Args:
        original_rule: The existing rule to wrap (e.g., native.cc_binary).
        settings: A dictionary of settings changes to apply.
        executable: Whether the new rule should be executable (default: False).
        test: Whether the new rule should be a test rule (default: False).
        extra_providers: Additional providers that the wrapping rule should forward from the original rule.

    Returns:
        A new rule that behaves like the original rule after applying the provided changes to the build settings.
    """
    is_native_rule = str(original_rule).startswith("<built-in rule ")
    native_rule_name = None
    if is_native_rule:
        native_rule_name = str(original_rule)[len("<built-in rule "):-1]

    raw_value_settings = {}
    attr_settings = {}
    attr_counter = 0
    for setting, value in settings.items():
        full_setting = _maybe_add_command_line_option_prefix(setting)
        if is_dict(value):
            attr_settings[full_setting] = struct(
                name = "attr_%d" % attr_counter,
                type = attr_from_value(value),
                value = select(value),
            )
            attr_counter += 1
        elif is_select(value):
            fail("Instead of select({...}), use {...} as the value of setting '%s'." % setting)
        else:
            raw_value_settings[full_setting] = value

    all_settings = raw_value_settings.keys() + attr_settings.keys()

    def _transition_impl(input_settings, attrs):
        updated_settings = {}
        for setting in all_settings:
            if setting in raw_value_settings:
                new_value = raw_value_settings[setting]
            else:
                new_value = getattr(attrs, attr_settings[setting].name)
            if is_list(new_value):
                updated_settings[setting] = input_settings[setting] + new_value
            else:
                updated_settings[setting] = new_value
        return updated_settings

    _transition = transition(
        implementation = _transition_impl,
        inputs = all_settings,
        outputs = all_settings,
    )

    _apply_transition_rule = transition_and_forward_providers_factory(
        _transition,
        attrs = {
            attr.name: attr.type
            for attr in attr_settings.values()
        },
        executable = executable,
        test = test,
        extra_providers = extra_providers,
    )

    def _wrapper_macro(name, visibility = None, tags = None, testonly = None, **kwargs):
        unsupported_attr = None
        if is_native_rule:
            if kwargs.get("env") != None and not test:
                unsupported_attr = "env"
            elif kwargs.get("env_inherit") != None:
                unsupported_attr = "env_inherit"
            elif kwargs.get("args") != None:
                unsupported_attr = "args"

        if unsupported_attr != None:
            fail("Setting the '{unsupported_attr}' attribute of '{native_rule_name}' on the transition wrapper generated by rules_meta is not yet supported.".format(
                unsupported_attr = unsupported_attr,
                native_rule_name = native_rule_name,
            ))

        # Use a subdirectory to preserve the basename but still prevent a name
        # collision with the transition rule.
        orig_name = "{name}/{name}".format(name = name)

        internal_rule_tags = list(tags or [])
        if "manual" not in internal_rule_tags:
            internal_rule_tags.append("manual")

        # Native test rules offer an env attribute that has to be moved to the wrapper.
        wrapper_env = kwargs.pop("env", default = None) if is_native_rule and test else None
        original_rule(
            name = orig_name,
            tags = internal_rule_tags,
            testonly = testonly,
            visibility = ["//visibility:private"],
            **kwargs
        )

        _apply_transition_rule(
            name = name,
            env = wrapper_env,
            exports = ":" + orig_name,
            tags = tags,
            testonly = testonly,
            visibility = visibility,
            **{
                attr.name: attr.value
                for attr in attr_settings.values()
            }
        )

    return _wrapper_macro

def _get_updated_value(new_value, current_value):
    if is_list(current_value):
        return current_value + new_value
    else:
        return new_value

def _maybe_add_command_line_option_prefix(setting):
    if not setting or not setting[0].isalpha():
        return setting
    else:
        return "//command_line_option:" + setting
